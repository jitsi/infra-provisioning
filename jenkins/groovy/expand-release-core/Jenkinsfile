// splits incoming clouds into a list
// alternately loads defaults for environment into a list
def split_clouds(shard_environment,cloud_names) {
    if (cloud_names) {
        clouds = cloud_names.split(' ')
    } else {
        clouds = sh(
            returnStdout: true,
            script: 'scripts/release_clouds.sh '+shard_environment
        ).trim().split(' ');
    }
    return clouds
}

def reconfigureEnvironment(hcv_environment) {
    def result = build job: 'reconfigure-autoscaler-environment',wait: true,parameters: [
        [$class: 'StringParameterValue', name: 'ENVIRONMENT', value: hcv_environment],
        [$class: 'StringParameterValue', name: 'VIDEO_INFRA_BRANCH', value: env.VIDEO_INFRA_BRANCH]
    ]
    return result
}

// generates unique new shard numbers for environment based on existing shards currently deployed
def expand_release() {
    sh(
        script: 'scripts/expand-release.sh ubuntu'
    )
    awsShardsByCloud = readJSON file: 'add-shards-by-cloud-aws.json'
    oracleShardsByCloud = readJSON file: 'add-shards-by-cloud-oracle.json'


    return [awsShardsByCloud: awsShardsByCloud, oracleShardsByCloud: oracleShardsByCloud];
}

// global var to track git branch from env or new tags
def git_branch

// global var to track whether parallel tasks were started or not
def shards_created = false;


// trigger create shard job with appopriate parameters
def createShard(shard_environment,cloud_name,core_cloud_provider,cloud_provider,shard_count,shard_numbers,release_number,gitBranch,jvbVersion,signalVersion) {
    def createShard = build job: 'provision-shard',parameters: [
        [$class: 'StringParameterValue', name: 'ENVIRONMENT', value: shard_environment],
        [$class: 'StringParameterValue', name: 'CLOUD_NAME', value: cloud_name],
        [$class: 'StringParameterValue', name: 'CLOUD_PROVIDER', value: cloud_provider],
        [$class: 'StringParameterValue', name: 'CORE_CLOUD_PROVIDER', value: core_cloud_provider],
        [$class: 'StringParameterValue', name: 'SHARD_COUNT', value: shard_count],
        [$class: 'StringParameterValue', name: 'SHARD_NUMBERS', value: shard_numbers],
        [$class: 'StringParameterValue', name: 'SIGNAL_VERSION', value: signalVersion],
        [$class: 'StringParameterValue', name: 'JVB_VERSION', value: jvbVersion],
        [$class: 'StringParameterValue', name: 'RELEASE_NUMBER', value: release_number],
        [$class: 'StringParameterValue', name: 'RELEASE_BRANCH', value: gitBranch]
    ]

    return createShard
}

pipeline {				//indicate the job is written in Declarative Pipeline
    agent any				//agent specifies where the pipeline will execute. 
    options {
        ansiColor('xterm')
        timestamps()
    }
    stages {
        stage('Prepare/Checkout') { // for display purposes
            steps {
                script {
                    def scmUrl = scm.getUserRemoteConfigs()[0].getUrl()
                    dir('infra-customization') {
                        git branch: env.VIDEO_INFRA_BRANCH, url: env.INFRA_CUSTOMIZATIONS_REPO, credentialsId: 'video-infra'
                    }
                    dir('infra-configuration') {
                        git branch: env.VIDEO_INFRA_BRANCH, url: env.INFRA_CONFIGURATION_REPO, credentialsId: 'video-infra'
                    }
                    dir('infra-provisioning') {
                        git branch: env.VIDEO_INFRA_BRANCH, url: scmUrl, credentialsId: 'video-infra'
                    }

                    sh 'cp -a infra-customization/* infra-provisioning'
                    sh 'cp -a infra-customization/* infra-configuration'
                }
            }
        }
        // output stage, shows off our input parameters
        stage ("setup") {
            steps {
                echo 'Jitsi Release Expansion Starting'
                echo "JVB VERSION ${env.JVB_VERSION}"
                echo "SIGNAL VERSION ${env.SIGNAL_VERSION}"
                echo "CLOUDS ${env.CLOUDS}"
                echo "RELEASE NUMBER ${env.RELEASE_NUMBER}"
                echo "GIT BRANCH ${git_branch}"
            }
        }
        stage("create shards") {
            steps {
                script {
                    withCredentials([
                            string(credentialsId: 'jenkins-aws-secret', variable: 'AWS_SECRET_ACCESS_KEY'),
                            string(credentialsId: 'jenkins-aws-id', variable: 'AWS_ACCESS_KEY_ID')
                    ]) {
                        dir('infra-provisioning') {
                            echo "Create shards in ${env.ENVIRONMENT} clouds ${env.CLOUDS}";
                            def cloud_list = split_clouds(env.ENVIRONMENT,env.CLOUDS);
                            def shards_by_cloud;
                            def aws_shards_by_cloud;
                            def oracle_shards_by_cloud;
                            echo "cloud list ${cloud_list}";
                            shards_by_cloud = expand_release();
                            oracle_shards_by_cloud = shards_by_cloud.oracleShardsByCloud
                            aws_shards_by_cloud = shards_by_cloud.awsShardsByCloud
                            def branches = [:]
                            for(i = 0; i < cloud_list.size(); i++) {
                                def curr = i
                                echo "pipeline branch ${curr} for shard ${cloud_list[curr]}";
                                if (aws_shards_by_cloud.containsKey(cloud_list[curr])) {
                                    shards_created = true;
                                    def shard_count = aws_shards_by_cloud[cloud_list[curr]].split(' ').size().toString()
                                    echo "createShard ${env.ENVIRONMENT} ${cloud_list[curr]} ${shard_count} ${aws_shards_by_cloud[cloud_list[curr]]} ${env.RELEASE_NUMBER} ${git_branch} ${env.JVB_VERSION} ${env.SIGNAL_VERSION}"
                                    branches["aws ${cloud_list[curr]}"] = {
                                        createShard(env.ENVIRONMENT,
                                            cloud_list[curr],
                                            "aws",
                                            "aws",
                                            shard_count,
                                            aws_shards_by_cloud[cloud_list[curr]],
                                            env.RELEASE_NUMBER,
                                            git_branch,
                                            env.JVB_VERSION,
                                            env.SIGNAL_VERSION
                                        ) 
                                    }
                                }
                            }
                            for(i = 0; i < cloud_list.size(); i++) {
                                def curr = i
                                echo "pipeline branch ${curr} for shard ${cloud_list[curr]}";
                                if (oracle_shards_by_cloud.containsKey(cloud_list[curr])) {
                                    shards_created = true;
                                    def oracle_shards = oracle_shards_by_cloud[cloud_list[curr]].split(' ')
                                    def shard_count = oracle_shards.size();
                                    echo "createShard ${env.ENVIRONMENT} ${cloud_list[curr]} ${shard_count.toString()} ${oracle_shards_by_cloud[cloud_list[curr]]} ${env.RELEASE_NUMBER} ${git_branch} ${env.JVB_VERSION} ${env.SIGNAL_VERSION}"
                                    for(j = 0; j < shard_count; j++) {
                                        def s = j
                                        branches["oracle ${cloud_list[curr]} ${j}"] = {
                                            createShard(env.ENVIRONMENT,
                                                cloud_list[curr],
                                                env.CORE_CLOUD_PROVIDER,
                                                "oracle",
                                                "1",
                                                oracle_shards[s],
                                                env.RELEASE_NUMBER,
                                                git_branch,
                                                env.JVB_VERSION,
                                                env.SIGNAL_VERSION
                                            ) 
                                        }
                                    }
                                }
                            }
                            // branch out here, run all create shard jobs at once
                            // only succeed if all branches succeed
                            parallel branches                    
                        }
                    }
                }
            }
        }
        stage("Trigger autoscaler reconfiguration") {
            steps {
                script {
                    reconfigureEnvironment(env.ENVIRONMENT)
                }
            }
        }
        // trigger rotation of load balancers to discover new shards
        stage ("rotate load balancers") {
            steps {
                script {
                    if (shards_created) {
                        build job: 'reconfigure-haproxy',parameters: [
                            [$class: 'StringParameterValue', name: 'ENVIRONMENT', value: env.ENVIRONMENT],
                            [$class: 'StringParameterValue', name: 'VIDEO_INFRA_BRANCH', value: env.VIDEO_INFRA_BRANCH]
                        ]
                    }
                }
            }
        }
    }
}