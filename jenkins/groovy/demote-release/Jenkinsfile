def listJVBPools(release_number) {
    pools=[:]
    def poolsStr = sh(
        returnStdout: true,
        script: """
        export RELEASE_NUMBER="${release_number}"
        scripts/list-jvb-pools.sh"""
    ).trim();

    if (poolsStr.length() > 0) {
        pools = poolsStr.split(' ');
    }
    return pools
}

def getReleaseBranchFromPools(environment, pools) {
    if (pools.size() > 0) {
        def firstPool = pools[0]
        def releaseBranch = sh(
            returnStdout: true,
            script: """
            export ENVIRONMENT="${environment}"
            export JVB_POOL_NAME="${firstPool}"
            scripts/get-release-branch-from-jvb-pool.sh || echo "main"
            """
        ).trim()
        return releaseBranch ?: "main"
    }
    return "main"
}

def provisionGlobalPool(environment, oracle_region, cloud_provider, release_branch, release_number, jvb_version, video_infra_branch) {
    def provision_job = build job: 'provision-jvb-pool',wait: true,parameters: [
        [$class: 'StringParameterValue', name: 'ENVIRONMENT', value: environment],
        [$class: 'StringParameterValue', name: 'ORACLE_REGION', value: oracle_region],
        [$class: 'StringParameterValue', name: 'CLOUD_PROVIDER', value: cloud_provider],
        [$class: 'StringParameterValue', name: 'RELEASE_BRANCH', value: release_branch],
        [$class: 'StringParameterValue', name: 'RELEASE_NUMBER', value: release_number],
        [$class: 'StringParameterValue', name: 'JVB_VERSION', value: jvb_version],
        [$class: 'StringParameterValue', name: 'JVB_POOL_MODE', value: 'global'],
        [$class: 'StringParameterValue', name: 'VIDEO_INFRA_BRANCH', value: video_infra_branch]
    ]
    return provision_job
}

def setPoolDesiredCount(environment, pool_name, desired_count, min_count, max_count) {
    build job: 'reconfigure-autoscaler-desired-values',wait: true,parameters: [
        [$class: 'StringParameterValue', name: 'ENVIRONMENT', value: environment],
        [$class: 'StringParameterValue', name: 'GROUP_NAME', value: "${pool_name}-JVBCustomGroup"],
        [$class: 'StringParameterValue', name: 'DESIRED_COUNT', value: desired_count.toString()],
        [$class: 'StringParameterValue', name: 'MIN_DESIRED', value: min_count.toString()],
        [$class: 'StringParameterValue', name: 'MAX_DESIRED', value: max_count.toString()],
        [$class: 'StringParameterValue', name: 'VIDEO_INFRA_BRANCH', value: env.VIDEO_INFRA_BRANCH]
    ]
}

def deleteJVBPool(hcv_environment, jvb_pool_name) {
    def deletePool = build job: 'destroy-jvb-pool',parameters: [
        [$class: 'StringParameterValue', name: 'ENVIRONMENT', value: hcv_environment],
        [$class: 'StringParameterValue', name: 'JVB_POOL_NAME', value: jvb_pool_name],
        [$class: 'StringParameterValue', name: 'VIDEO_INFRA_BRANCH', value: env.VIDEO_INFRA_BRANCH]
    ]
    return deletePool
}

def filterPoolsByMode(pools, mode) {
    def filtered = []
    for (pool in pools) {
        if (pool.contains("-${mode}-")) {
            filtered.add(pool)
        }
    }
    return filtered
}

def utils
def existingPools = []
def localPools = []
def remotePools = []
def globalPools = []
def releaseBranch = ""
def cloud_list = []
def shardsByRegion = [:]
def shardsToKeep = []
def shardsToDrain = []

pipeline {
    agent any
    options {
        ansiColor('xterm')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10', artifactNumToKeepStr: '10'))
    }
    stages {
        stage('Prepare/Checkout') {
            steps {
                script {
                    def rootDir = pwd()
                    utils = load "${rootDir}/jenkins/groovy/Utils.groovy"
                    utils.SetupRepos(env.VIDEO_INFRA_BRANCH)
                    utils.SetupOCI()
                }
            }
        }
        stage("Setup") {
            steps {
                echo 'Jitsi Release Demote Starting'
                echo "ENVIRONMENT ${env.ENVIRONMENT}"
                echo "RELEASE_NUMBER ${env.RELEASE_NUMBER}"
                echo "CLOUDS ${env.CLOUDS}"
                echo "JVB_VERSION ${env.JVB_VERSION}"
            }
        }
        stage("List existing pools") {
            steps {
                script {
                    dir('infra-provisioning') {
                        withCredentials([
                            string(credentialsId: 'asap-jwt-kid-dev', variable: 'ASAP_JWT_KID_DEV'),
                            string(credentialsId: 'asap-jwt-kid-prod', variable: 'ASAP_JWT_KID_PROD'),
                            file(credentialsId: 'asap-jwt-key-dev', variable: 'ASAP_JWT_KEY_DEV'),
                            file(credentialsId: 'asap-jwt-key-prod', variable: 'ASAP_JWT_KEY_PROD')
                        ]) {
                            sshagent(credentials: ['ssh-ubuntu']) {
                                cloud_list = utils.SplitClouds(env.ENVIRONMENT,env.CLOUDS);
                                existingPools = listJVBPools(env.RELEASE_NUMBER)
                                echo "Existing JVB pools found:"
                                echo "${existingPools}"
                                
                                if (existingPools.size() > 0) {
                                    releaseBranch = getReleaseBranchFromPools(env.ENVIRONMENT, existingPools)
                                    echo "Release branch detected: ${releaseBranch}"
                                    
                                    localPools = filterPoolsByMode(existingPools, "local")
                                    remotePools = filterPoolsByMode(existingPools, "remote")
                                    globalPools = filterPoolsByMode(existingPools, "global")
                                    
                                    echo "Local pools: ${localPools}"
                                    echo "Remote pools: ${remotePools}"
                                    echo "Global pools: ${globalPools}"
                                } else {
                                    error("No JVB pools found for release ${env.RELEASE_NUMBER}")
                                }
                            }
                        }
                    }
                }
            }
        }
        stage("Provision global pool") {
            // when {
            //     expression {
            //         return globalPools.size() < cloud_list.size()
            //     }
            // }
            steps {
                script {
                  dir('infra-provisioning') {
                    withCredentials([
                        string(credentialsId: 'asap-jwt-kid-dev', variable: 'ASAP_JWT_KID_DEV'),
                        string(credentialsId: 'asap-jwt-kid-prod', variable: 'ASAP_JWT_KID_PROD'),
                        file(credentialsId: 'asap-jwt-key-dev', variable: 'ASAP_JWT_KEY_DEV'),
                        file(credentialsId: 'asap-jwt-key-prod', variable: 'ASAP_JWT_KEY_PROD')
                    ]) {
                        sshagent(credentials: ['ssh-ubuntu']) {
                        echo "No global pool found, provisioning new global pool where missing"
                        // loop on regions and provision global pools
                        cloud_list = utils.SplitClouds(env.ENVIRONMENT,env.CLOUDS);
                        def shard_base = utils.GetShardBase(env.ENVIRONMENT)
                        echo "cloud list ${cloud_list}";
                        def branches = [:]
                        for(i = 0; i < cloud_list.size(); i++) {
                            def curr = i
                            def oracle_region = utils.OracleRegionFromCloud(cloud_list[curr])
                            def pool_name = "${shard_base}-${oracle_region}-global-${env.RELEASE_NUMBER}"
                            def foundPool = false
                            for (String pool : globalPools) {
                                if (pool == pool_name) {
                                    foundPool = true
                                    break
                                }
                            }
                            if (foundPool) {
                                echo "Pool ${pool_name} already exists, not re-provisioning"
                            } else {
                                echo "pipeline branch ${curr} for shard ${cloud_list[curr]} ${oracle_region}";
                                branches["Provision ${cloud_list[curr]}"] = {
                                    provisionGlobalPool(
                                        env.ENVIRONMENT,
                                        oracle_region,
                                        env.CLOUD_PROVIDER,
                                        releaseBranch,
                                        env.RELEASE_NUMBER,
                                        env.JVB_VERSION,
                                        env.VIDEO_INFRA_BRANCH
                                    )
                                }
                            }
                        }
                        // branch out here, run all create shard jobs at once
                        // only succeed if all branches succeed
                        parallel branches
                      }
                    }
                  }
                }
            }
        }
        stage("Wait for confirmation") {
            when {
                expression {
                    if (localPools.size() > 0 || remotePools.size() > 0) {
                        input message: 'Global pool is ready. Proceed with draining and deleting local/remote pools?'
                        return true
                    } else {
                        echo "No pools to remove, skipping drain & delete"
                        return false
                    }
                }
            }
            steps {
                echo "Proceeding with pool demotion"
            }
        }
        stage("Set local and remote pools desired count to 0") {
            when {
                expression {
                    return (localPools.size() > 0 || remotePools.size() > 0)
                }
            }
            steps {
                script {
                    def poolsToDrain = []
                    poolsToDrain.addAll(localPools)
                    poolsToDrain.addAll(remotePools)
                    
                    echo "Setting desired count to 0 for pools: ${poolsToDrain}"
                    
                    def branches = [:]
                    for(i = 0; i < poolsToDrain.size(); i++) {
                        def pcurr = i
                        branches["Scale down ${poolsToDrain[pcurr]}"] = {
                            setPoolDesiredCount(env.ENVIRONMENT, poolsToDrain[pcurr], 0, 0, 0)
                        }
                    }
                    parallel branches
                }
            }
        }
        stage("Wait for pools to drain") {
            when {
                expression {
                    return (localPools.size() > 0 || remotePools.size() > 0)
                }
            }
            steps {
                script {
                    echo "Sleeping for ${env.DRAIN_WAIT_PERIOD} seconds to allow pools to drain"
                    sleep env.DRAIN_WAIT_PERIOD.toInteger()
                }
            }
        }
        stage("Delete local and remote pools") {
            when {
                expression {
                    return (localPools.size() > 0 || remotePools.size() > 0)
                }
            }
            steps {
                script {
                    def branches = [:]
                    def poolsToDelete = []
                    poolsToDelete.addAll(localPools)
                    poolsToDelete.addAll(remotePools)
                    
                    if (poolsToDelete.size() > 0) {
                        for(i = 0; i < poolsToDelete.size(); i++) {
                            def pcurr = i
                            branches["Pool ${poolsToDelete[pcurr]}"] = {
                                deleteJVBPool(
                                    env.ENVIRONMENT,
                                    poolsToDelete[pcurr]
                                )
                            }
                        }
                        echo "Deleting pools: ${poolsToDelete}"
                        parallel branches
                    } else {
                        echo 'No local or remote JVB pools to delete'
                    }
                }
            }
        }
        stage("List existing shards") {
            steps {
                script {
                    dir('infra-provisioning') {
                        withCredentials([
                            string(credentialsId: 'asap-jwt-kid-dev', variable: 'ASAP_JWT_KID_DEV'),
                            string(credentialsId: 'asap-jwt-kid-prod', variable: 'ASAP_JWT_KID_PROD'),
                            file(credentialsId: 'asap-jwt-key-dev', variable: 'ASAP_JWT_KEY_DEV'),
                            file(credentialsId: 'asap-jwt-key-prod', variable: 'ASAP_JWT_KEY_PROD')
                        ]) {
                            sshagent(credentials: ['ssh-ubuntu']) {
                                // Get all shards for the release
                                def shardsStr = sh(
                                    returnStdout: true,
                                    script: """
                                    export RELEASE_NUMBER="${env.RELEASE_NUMBER}"
                                    export ENVIRONMENT="${env.ENVIRONMENT}"
                                    scripts/list-release-shards.sh
                                    """
                                ).trim()

                                if (shardsStr.length() > 0) {
                                    def allShards = shardsStr.split(' ')
                                    echo "Found ${allShards.size()} shards for release ${env.RELEASE_NUMBER}:"
                                    echo "${allShards}"

                                    // Group shards by region
                                    for (shard in allShards) {
                                        def region = sh(
                                            returnStdout: true,
                                            script: """
                                            export ENVIRONMENT="${env.ENVIRONMENT}"
                                            export SHARD="${shard}"
                                            scripts/shard.sh shard_region
                                            """
                                        ).trim()

                                        if (!shardsByRegion.containsKey(region)) {
                                            shardsByRegion[region] = []
                                        }
                                        shardsByRegion[region].add(shard)
                                    }

                                    echo "Shards grouped by region:"
                                    shardsByRegion.each { region, shards ->
                                        echo "  ${region}: ${shards}"
                                    }

                                    // Determine which shards to keep (one per region) and which to drain
                                    shardsByRegion.each { region, shards ->
                                        if (shards.size() > 0) {
                                            // Keep the first shard in each region
                                            shardsToKeep.add(shards[0])
                                            echo "Keeping shard ${shards[0]} in region ${region}"

                                            // Mark remaining shards for draining
                                            if (shards.size() > 1) {
                                                for (int i = 1; i < shards.size(); i++) {
                                                    shardsToDrain.add(shards[i])
                                                    echo "Marking shard ${shards[i]} for draining in region ${region}"
                                                }
                                            }
                                        }
                                    }

                                    echo "Summary:"
                                    echo "  Shards to keep: ${shardsToKeep}"
                                    echo "  Shards to drain: ${shardsToDrain}"
                                } else {
                                    echo "No shards found for release ${env.RELEASE_NUMBER}"
                                }
                            }
                        }
                    }
                }
            }
        }
        stage("Drain extraneous shards") {
            when {
                expression {
                    return shardsToDrain.size() > 0
                }
            }
            steps {
                script {
                    dir('infra-provisioning') {
                        withCredentials([
                            string(credentialsId: 'asap-jwt-kid-dev', variable: 'ASAP_JWT_KID_DEV'),
                            string(credentialsId: 'asap-jwt-kid-prod', variable: 'ASAP_JWT_KID_PROD'),
                            file(credentialsId: 'asap-jwt-key-dev', variable: 'ASAP_JWT_KEY_DEV'),
                            file(credentialsId: 'asap-jwt-key-prod', variable: 'ASAP_JWT_KEY_PROD')
                        ]) {
                            sshagent(credentials: ['ssh-ubuntu']) {
                                echo "Draining ${shardsToDrain.size()} extraneous shards"

                                // Build the SHARDS_READY and SHARDS_DRAIN environment variables
                                def shardsReadyStr = shardsToKeep.join(' ')
                                def shardsDrainStr = shardsToDrain.join(' ')

                                echo "Setting shard states:"
                                echo "  SHARDS_READY: ${shardsReadyStr}"
                                echo "  SHARDS_DRAIN: ${shardsDrainStr}"

                                // Call set-haproxy-shard-states.sh to drain the shards
                                sh """
                                export ENVIRONMENT="${env.ENVIRONMENT}"
                                export SHARDS_READY="${shardsReadyStr}"
                                export SHARDS_DRAIN="${shardsDrainStr}"
                                scripts/set-haproxy-shard-states.sh ubuntu
                                """

                                echo "Successfully drained extraneous shards"
                            }
                        }
                    }
                }
            }

        }
    }
}